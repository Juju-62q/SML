1.accumulateの作成課題

[実行結果]
- summation (fn x => x) 5;
val it = 15 : int
- f1 5;
val it = 15 : int
- f2 5;
val it = 120 : int
- f3 5 3;
val it = 1641 : int

[考察]
accumulateについて
accumulateは h z f n と4つの変数を持つ関数である。

hは全体の解を計算するために各校を組み合わせる演算をする関数
zは初期値
fはk番目の項を計算するための関数
nは項の数を示している。

なお、動作確認に関しては以降の各関数が正常に計算されていることで確認するものとする。

summationについて
summationは以下のような漸化式である。

              f(1) ... n = 1
summation = 
              summation f (n - 1) ... n > 1

本課題ではfに入力値をそのまま返す関数、nに5を与えて実行した。
つまり 1 + 2 + 3 + 4 + 5という計算をしたことになる。
この式の計算結果は15であり、これはプログラムの出力と一致しているためsummationは正常にどうさしていると解る。

f1について
f1は以下のような漸化式である。

        0 ... n = 0
f1(n) =
        n + f1(n - 1) ... n > 0
nに5を与えて実行した。
つまり 1 + 2 + 3 + 4 + 5という計算をしたことになる。
この式の計算結果は15であり、これはプログラムの出力と一致しているためf1は正常にどうさしていると解る。

f2について
f2は以下のような漸化式である。

        1 ... n = 0
f2(n) =
        n * f1(n - 1) ... n > 0
nに5を与えて実行した。
つまり 1 * 2 * 3 * 4 * 5という計算をしたことになる。
この式の計算結果は120であり、これはプログラムの出力と一致しているためf2は正常にどうさしていると解る。

f3について
f3は以下のような漸化式である。

           0 ... n = 0
f3(n, x) =
           n * x^n + f3(n - 1, x) ... n > 0
nに5, xに3を与えて実行した。
つまり 1*3^1 + 2*3^2 + 3*3^3 + 4*3^4 + 5*3^5という計算をしたことになる。
この式の計算結果は1641であり、これはプログラムの出力と一致しているためf3は正常にどうさしていると解る。
2.fibonacciのあまりの作成課題

[実行結果]
- time g1_5 ();
0.696893 sec.
val it = (true,false,false,false,true) : bool * bool * bool * bool * bool
- time g2_5 ();
0.0 sec.
val it = (true,false,false,false,true) : bool * bool * bool * bool * bool

[考察]
g1_5とg2_5の実効速度を比較するとg2_5の方が圧倒的に高速に動作していた。
これはg2_5ではg2の定義時点でfib 35を計算しており、数字の余剰項を計算しているだけで非常に高速に動作しているためである。
これに対しg1_5ではg1の定義ではfib 35の値を計算しておらず呼び出される度にフィボナッチ数列を計算しており動作が遅くなってしまっている。
以上の理由から2つの関数を比較したときにg2_5の方が高速に動作した。
